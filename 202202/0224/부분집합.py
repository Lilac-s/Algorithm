def f(i, r): # 길이가 r인 부분집합을 찾는 함수. i는 인덱싱 하는 데 쓰인다. 함수 실행할 때 모든 부분집합을 구하고자 한다면 i = 0으로 시작한다.
    if i==r: # i가 r하고 같아지면
        print(bit) # 만들어진 부분집합을 프린트하고
        return # 함수를 끝낸다.
    # 아직 i하고 r이 다르다면
    bit[i] = 0 # bit의 i번째를 인덱싱해서 0으로 만들어 놓고
    f(i+1,r) # i를 하나 증가시켜서 함수를 다시 호출한다.(재귀)
    bit[i] = 1 # bit의 i번째를 인덱싱해서 1으로 만들어 놓고
    f(i+1,r) # i를 하나 증가시켜서 함수를 다시 호출한다.(재귀)
    # 그리고 이 함수는 끝을 낸다.

# 위와 같이 하나의 함수가 끝날 때 함수를 2번 호출하면, 아래로 내려갈수록 그 수가 2배씩 증가하는 재귀함수가 만들어진다.
# 만들어진 모든 함수는 각각의 bit 리스트를 가지고 하나씩 인덱싱하며 bit 리스트를 변화시킨다.
# 그렇게 다 변화된 bit 리스트는 i와 r이 같아지는 시점에 프린트가 된다.
# 호출된 모든 함수가 i와 r이 같아지는 시점으로 가서 프린트가 되면, 모든 부분집합이 구해진다.

N = 4 # 부분집합의 길이
lst = list(range(1,N))
bit = [0]*N # 부분집합의 길이만큼 리스트를 만든다.
f(0, N) # 길이가 N인 부분집합이 몇 개가 있는지 찾아보겠어.